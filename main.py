import sys
from PySide6 import QtWidgets
from PySide6.QtUiTools import QUiLoader
import hashlib
import pefile
import capstone

loader = QUiLoader() #Used to set up a loader object

app = QtWidgets.QApplication(sys.argv)
#using this we load the user interface at run time. The .ui files were formed using QT designer.
window = loader.load("widget.ui", None)
window2 = loader.load("output.ui",None)

#Usng this function we calculate the hash of the executable file by using the md5 hash algorithm.
def calculate_file_hash(file_path, hash_algorithm="md5", chunk_size=8192):
    hash_obj = hashlib.new(hash_algorithm)
    with open(file_path, "rb") as f:
        while chunk := f.read(chunk_size):
            hash_obj.update(chunk)
    return hash_obj.hexdigest()

#With this function we check if the executable file is infected by comparing its hash against a list of known malware signatures.
def is_file_infected(file_path, signature_list):
    file_hash = calculate_file_hash(file_path)
    return file_hash in signature_list

#This function takes the file path of th file to be tested for malware. Be sure to use "/" in file path instead of "\".
def load_pe_file(file_path):
    try:
        pe = pefile.PE(file_path)
        return pe
    except pefile.PEFormatError as e:
        print("Error loading the PE file:", str(e))
        return None

#Finds the basic information of the file such as path, image base, timestamp, etc. 
def print_pe_info(pe):
    a = [f"File Path: ",window.file_path.text(),
         f"Image Base: 0x{pe.OPTIONAL_HEADER.ImageBase:08X}",
         f"Entry Point: 0x{pe.OPTIONAL_HEADER.AddressOfEntryPoint:08X}",
         f"Number of Sections: {pe.FILE_HEADER.NumberOfSections}",
         f"Timestamp: {pe.FILE_HEADER.TimeDateStamp}"]
    window2.output_text.setText(str(a))
    
#Breaks down the the code of the file and displays it. 
def disassemble_code(pe):
    code_section = None
    for section in pe.sections:
        if ".text" in section.Name.decode().strip('\x00'):
            code_section = section
            break

    if not code_section:
        print("No code section found.")
        return

    code_offset = code_section.VirtualAddress
    code_size = code_section.Misc_VirtualSize

    code_data = pe.get_memory_mapped_image()[code_offset:code_offset + code_size]
    md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32 if pe.FILE_HEADER.Machine == 0x014c else capstone.S_MODE_64)

    #produces the dissassembled code.
    z=[]
    for i in md.disasm(code_data, code_offset):
        z.append("0x{:x}:n{} {}".format(i.address, i.mnemonic, i.op_str))
    window2.output_code.setText(str(z))

# this function finds and displays all the imported functions within the executable file code.
def analyze_functions(pe):
    y=[]
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        y.append(f"{entry.dll.decode()}")
        for imp in entry.imports:
            y.append(f"{imp.name.decode() if imp.name else str(imp.ordinal)}")
    window2.output_functions.setText(str(y))

    # We can add many more analysis techniques based upon our knowledge and requirements.

#checks if file portale executable and then passes it to the various functions for processing.
def generate_report(file_path):
    pe = load_pe_file(file_path)
    if not pe:
        return

    print_pe_info(pe)
    disassemble_code(pe)
    analyze_functions(pe)

    # We can add more analysis functions as needed

def do_something() :
    # 'list.txt' contains millions of updated md5 hashes of known malware, obained from virusshare.com
    with open("list.txt") as f:
        malware_signatures = set(line.strip() for line in f)

    file_to_check = window.file_path.text()

    if is_file_infected(file_to_check, malware_signatures):
        window2.output_result.setText("File is infected with known malware!")
    else:
        window2.output_result.setText("File is clean!")
    malware_file_path = window.file_path.text()
    generate_report(malware_file_path)
    window2.show()


#This allows us to Change the properties in the form such as the titles of the windows.
window.setWindowTitle("J.A.G.G.S. Malware Analyser")
window2.setWindowTitle("J.A.G.G.S. Malware Analyser")

#here we are aAccessing widgets within the form
window.analyse_button.clicked.connect(do_something)
window.show()
app.exec()